diff --git a/http/Server.zig b/http/Server.zig
index 25d3e44..683078c 100644
--- a/http/Server.zig
+++ b/http/Server.zig
@@ -14,6 +14,11 @@ read_buffer_len: usize,
 /// Index into `read_buffer` of the first byte of the next HTTP request.
 next_request_start: usize,
 
+uuid: u32,
+proxy_reader: ?*const fn (uuid: u32, connection: *std.net.Server.Connection, buffer: []u8, first_read: bool) std.posix.ReadError!usize,
+proxy_response: ?*const fn (iovecs: []std.posix.iovec_const, stream: *std.net.Stream, enable_signing: bool) error{Unexpected}!void,
+enable_signing: bool,
+
 pub const State = enum {
     /// The connection is available to be used for the first time, or reused.
     ready,
@@ -29,16 +34,23 @@ pub const State = enum {
     closing,
 };
 
+var uuid_counter: u32 = 0;
+
 /// Initialize an HTTP server that can respond to multiple requests on the same
 /// connection.
 /// The returned `Server` is ready for `receiveHead` to be called.
 pub fn init(connection: net.Server.Connection, read_buffer: []u8) Server {
+    uuid_counter += 1;
     return .{
         .connection = connection,
         .state = .ready,
         .read_buffer = read_buffer,
         .read_buffer_len = 0,
         .next_request_start = 0,
+        .proxy_reader = null,
+        .proxy_response = null,
+        .enable_signing = false,
+        .uuid = uuid_counter,
     };
 }
 
@@ -85,12 +97,22 @@ pub fn receiveHead(s: *Server) ReceiveHeadError!Request {
             return finishReceivingHead(s, end);
     }
 
+    var first_read = true;
+
     while (true) {
         const buf = s.read_buffer[s.read_buffer_len..];
         if (buf.len == 0)
             return error.HttpHeadersOversize;
-        const read_n = s.connection.stream.read(buf) catch
-            return error.HttpHeadersUnreadable;
+        var read_n: usize = 0;
+
+        if (s.proxy_reader) |proxy_reader| {
+            read_n = proxy_reader(s.uuid, &s.connection, buf, first_read) catch
+                return error.HttpHeadersUnreadable;
+            first_read = false;
+        } else {
+            read_n = s.connection.stream.read(buf) catch
+                return error.HttpHeadersUnreadable;
+        }
         if (read_n == 0) {
             if (s.read_buffer_len > 0) {
                 return error.HttpRequestTruncated;
@@ -98,6 +120,7 @@ pub fn receiveHead(s: *Server) ReceiveHeadError!Request {
                 return error.HttpConnectionClosing;
             }
         }
+
         s.read_buffer_len += read_n;
         const bytes = buf[0..read_n];
         const end = hp.feed(bytes);
@@ -524,7 +547,13 @@ pub const Request = struct {
             }
         }
 
-        try request.server.connection.stream.writevAll(iovecs[0..iovecs_len]);
+        if (request.server.proxy_response != null) {
+            request.server.proxy_response.?(iovecs[0..iovecs_len], &request.server.connection.stream, request.server.enable_signing) catch {
+                return error.Unexpected;
+            };
+        } else {
+            try request.server.connection.stream.writevAll(iovecs[0..iovecs_len]);
+        }
     }
 
     pub const RespondStreamingOptions = struct {
@@ -648,7 +677,14 @@ pub const Request = struct {
         const available = s.read_buffer[s.next_request_start..s.read_buffer_len];
         if (available.len > 0) return available;
         s.next_request_start = head_end;
-        s.read_buffer_len = head_end + try s.connection.stream.read(s.read_buffer[head_end..]);
+
+        var read_n: usize = 0;
+        if (s.proxy_reader) |proxy_reader| {
+            read_n = try proxy_reader(s.uuid, &s.connection, s.read_buffer[head_end..], false);
+        } else {
+            read_n = try s.connection.stream.read(s.read_buffer[head_end..]);
+        }
+        s.read_buffer_len = head_end + read_n;
         return s.read_buffer[head_end..s.read_buffer_len];
     }
 
